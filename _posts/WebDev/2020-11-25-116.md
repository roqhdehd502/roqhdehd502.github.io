---

layout: post
title: "데이터 타입과 연산"
date: 2020-11-25
categories: [WebDev]
cover-img: /assets/img/cover-img.jpg #건들지말것
#thumbnail-img: /assets/img/20-12-04_116_6번.jpg #내용에 사진이 없으면 생략
share-img: /assets/img/avatar-icon.png #건들지말것
tags: [키워드, 데이터타입, 보수연산, 이스케이스시퀀스, 형변환]

---

## 1. 키워드란 무엇인가? ##  

: 프로그래밍을 함에 있어서 변수, 상수, 메소드, 클래스 등 어떠한 기능을 가진 것을 표현할 때 사용하는 방식으로 데이터 타입이나 조건문, 접근 제한자 등을 지칭한다. 또한, 해당 키워드는 기능 외의 사용이 불가능하다는 특징이 있다.



## 2. 2의 보수법이란? ##  

: 2진수의 음수 표현을 위한 방법으로 예를 들어 10진수 -15가 있다고 가정한다.

1. **15(10) ...** 음수 기호를 제거하고 2진수로 변환한다.
2. **1111(2) ...** 2진수 상태에서 음수를 표현해야 하므로 1의 보수를 구한다.
3. **0000(2) ...** 1의 보수연산을 한 상태에서 1의 2진수 즉, 0001(2)을 더한다.
4. **0001(2) ...** 해당 값에서 음수 부호 비트인 1을 맨 앞자리에 추가한다.
5. **1001(2) ...** 따라서 이 값이 2의 보수법으로 표현된다.




## 3. 컴퓨터에서 음의 정수 표현방법에 대하여 설명하시오. ##  

: 컴퓨터는 기본적으로 2진수의 형태를 띈다. 따라서 10진수의 음수를 표현하기 위해선 2진수로 변환 후 보수 연산을 이용한 뒤 맨 앞자리에 부호비트 1을 표기한다. 




## 4. -5가 컴퓨터에서의 2진수 값을 나타내시오. ##  

: 10진수인 -5를 2진수로 표현하기 위한 과정은 다음과 같다.

1. **0101(2) ...** -5의 음수 부호를 제거 한 뒤 2진수로 변환한다.
2. **1010(2) ...** 2진수로 변환한 값 0101(2)을 1의 보수 연산한다.
3. **1011(2)...** 1의 2진수인 0001(2)을  더하여 2의 보수 연산한다.
4. 따라서, 10진수 -5는 2진수 값을 나타낼 때 1011(2)이 된다.




## 5. 실수에서 오차가 생기는 원인은 무엇인가? ##  

: 컴퓨터는 기본적으로 FSM(유한 상태 기계) 모델이다.
그런데 대수적인 관점에서의 실수는 값이 한정된 유리수와 값이 무한한 무리수를 포함하기 때문에 유한한 메모리를 가진 컴퓨터의 입장에서는 무리수를 표현할 수 없다. 따라서 이에 대한 근사값을 표기해야 하므로 오차가 생긴다.




## 6. 실수의 표현법은(고정소수법, 부동소수법)을 설명하시오. ##  

: 고정소수법의 경우 대표적으로 double 데이터 타입이 있으며 연산된 소수점 자리의 수 만큼 위치를 미리 정해두어 표현한다.
부동소수법의 경우 대표적으로 float 데이터 타입이 있으며 2진수의 값을 정규화 한 뒤 해당 라인을 지수부와 가수부로 나눠 표현한다.



## 7. 정밀도란 무엇인가요?  ##

: 무한한 실수값을 얼마나 근접하게 표현하는지의 척도를 의미한다.



## 8. 상수란 무엇이며 변수와의 차이는? ##

: 상수는 최초로 정한 값 이후로 변동되지 않는 수를 의미하며 변수의 경우 초기화한 값을 변하게 할 수 있는 차이점이 있다.



## 9. 초기화란 무엇인가? ##

: 선언한 변수나 상수의 값을 대입하는 과정을 의미한다.



## 10. 리터럴이란 무엇인가요? ##

: 선언한 데이터의 타입이 변하지 않는 것을 의미하며 대표적으로 원시타입이 있다.



## 11. 아래의 내용이 에러가 나는 이유와 수정방법은? ##

```java
System.out.println(3147483647 + 3147483648);
```

: 출력하는 과정에서 변수 선언 없이 일반적인 연산을 했을 때에는 int형으로 한다.
그러나 int형의 경우 4 byte의 데이터 타입이므로 위와 같은 연산을 했을 때 범위 값을 넘어서게 된다.
따라서 8 byte 정수 데이터 타입인 long을 통해 변환하여 계산한다.



## 12. 자동 형변환과 명시적 형변환에 대하여 설명하시오. ##

: 자동 형변환의 경우 선언한 데이터 타입이 초기화한 데이터 타입보다 클 때 큰 데이터 타입을 작은 데이터 타입에 맞춰 자동으로 변환하는 것을 의미하고
명시적 형변환은 선언한 데이터 타입이 초기화 한 데이터 타입보다 작을 때 작은 데이터 타입을 큰 타입으로 강제 변환하는 것(캐스팅)을 의미한다.



## 13. 아래의 에러가 나는 이유를 설명하고 수정하시오. ##

```java
int a = 3;
int b = 4;
    	
double result = a / b;
    	
System.out.println(result);
```

: 변수 a, b는 int 타입 즉, 정수형 데이터이다. 여기서 a / b의 연산이 이루어질때, 이는 정수 연산이 이루어지므로 소수점을 버린 값을 그대로 result에 대입하게 되어 0을 출력한다.
따라서 a, b를 선언할 때 double 타입으로 하거나 result를 초기화 하는 과정에서 피연산하는 변수 a, b 둘 중 하나를 double로 캐스팅한다.



## 14. 이스퀘이프 시퀀스의 종류를 나열하고 기능을 설명하시오. ##

: 자바에서의 이스케이프 시퀀스는 다음과 같다.

- \n : 명시된 해당 문자를 다음 라인으로 넘긴다. 

- \t : 명시된 해당 문자를 탭하여 띄운다.

- \r : 명시된 해당 문자를 본 라인의 처음으로 넘긴다.

- \\ : \와 같은 문자를 표현한다.

- \" : 큰 따옴표를 표현한다.

- \' : 작은 따옴표를 표현한다.

- \b :  명시된 해당 문자를 지운다.

- \u : 유니코드를 표현한다.

  

## 15. 아래의 출력결과를 확인하고, 130이 나오는 이유를 설명하시오. ##

```java
System.out.println('A' + 'A');
```

: 문자 'A'의 경우 ASCII 코드로 표현 된 65를 의미한다. 그로인해 이 둘이 정수 연산으로 처리가 되어(인코딩 된 값) 130(65 + 65)으로 출력이 된다.
